{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Golang_Desde_Cero/",
    "result": {"data":{"site":{"siteMetadata":{"title":"El Rincon Del MaQuinarias"}},"markdownRemark":{"id":"b3b735c5-9831-5dc1-aa4b-aa028fa56f48","excerpt":"Tabla de contenidos: Instalación Descarga Instalación Verificación de la instalación Configuración del entorno Variables de entorno Windows Linux Verificación…","html":"<h1>Tabla de contenidos:</h1>\n<ul>\n<li><a href=\"#instalaci-n\">Instalación</a>\n<ul>\n<li><a href=\"#descarga\">Descarga</a></li>\n<li><a href=\"#instalaci-n-1\">Instalación</a></li>\n<li><a href=\"#verificaci-n-de-la-instalaci-n\">Verificación de la instalación</a></li>\n</ul>\n</li>\n<li><a href=\"#configuraci-n-del-entorno\">Configuración del entorno</a>\n<ul>\n<li><a href=\"#variables-de-entorno\">Variables de entorno</a>\n<ul>\n<li><a href=\"#windows\">Windows</a></li>\n<li><a href=\"#linux\">Linux</a></li>\n<li><a href=\"#verificaci-n\">Verificación</a></li>\n</ul>\n</li>\n<li><a href=\"#entorno-de-desarrollo\">Entorno de desarrollo</a>\n<ul>\n<li><a href=\"#hola-mundo-en-visual-studio\">Hola mundo en Visual studio</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#zonas-b-sicas-en-un-archivo-go\">Zonas básicas En un archivo Go</a>\n<ul>\n<li><a href=\"#paquete\">Paquete</a></li>\n<li><a href=\"#import\">Import</a></li>\n<li><a href=\"#funci-n-principal\">Función Principal</a></li>\n</ul>\n</li>\n<li><a href=\"#variables\">Variables</a>\n<ul>\n<li><a href=\"#scope-de-variables-y-convenci-n-de-nombres\">Scope de variables y convención de nombres</a></li>\n<li><a href=\"#tipos-de-datos-b-sicos\">Tipos de datos básicos</a>\n<ul>\n<li><a href=\"#enteros\">Enteros</a>\n<ul>\n<li><a href=\"#signed-int--enteros-\">Signed int (Enteros)</a></li>\n<li><a href=\"#unsigned-int--enteros-\">Unsigned int (Enteros)</a></li>\n</ul>\n</li>\n<li><a href=\"#decimales\">Decimales</a></li>\n<li><a href=\"#n-meros-complejos\">Números complejos</a></li>\n<li><a href=\"#byte\">Byte</a></li>\n<li><a href=\"#rune\">Rune</a></li>\n<li><a href=\"#utf-8\">UTF-8</a></li>\n<li><a href=\"#string\">String</a></li>\n<li><a href=\"#booleanos\">Booleanos</a>\n<ul>\n<li><a href=\"#operadores-l-gicos\">Operadores lógicos</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#inicializaciones\">Inicializaciones</a>\n<ul>\n<li><a href=\"#inicializaci-n-completa\">Inicialización Completa</a></li>\n<li><a href=\"#inicializaci-n-tard-a\">Inicialización Tardía</a></li>\n<li><a href=\"#inicializaci-n-abreviada--type-inference-\">Inicialización Abreviada (Type Inference)</a></li>\n<li><a href=\"#inicializaci-n-m-ltiple\">Inicialización múltiple</a></li>\n</ul>\n</li>\n<li><a href=\"#colecciones\">Colecciones</a>\n<ul>\n<li><a href=\"#arrays\">Arrays</a>\n<ul>\n<li><a href=\"#instanciaci-n\">Instanciación</a>\n<ul>\n<li><a href=\"#forma-completa\">Forma Completa</a></li>\n<li><a href=\"#forma-elegante\">Forma Elegante</a></li>\n<li><a href=\"#declaraci-n-tard-a\">Declaración Tardía</a></li>\n</ul>\n</li>\n<li><a href=\"#punteros-en-arrays\">Punteros en Arrays</a></li>\n<li><a href=\"#punteros-en-arrays-1\">Punteros en Arrays</a></li>\n</ul>\n</li>\n<li><a href=\"#slices\">Slices</a>\n<ul>\n<li><a href=\"#instanciaci-n-1\">Instanciación</a>\n<ul>\n<li><a href=\"#forma-completa\">Forma completa</a></li>\n<li><a href=\"#copia-de-un-slice\">Copia de un slice</a></li>\n<li><a href=\"#copia-de-un-slice-con-cortes\">Copia de un Slice con cortes</a></li>\n<li><a href=\"#uso-de-make-para-la-instanciaci-n-de-slices\">Uso de make para la instanciación de slices</a></li>\n</ul>\n</li>\n<li><a href=\"#funciones-de-los-slice\">Funciones de los Slice</a>\n<ul>\n<li><a href=\"#adici-n-de-1-elemento--append-\">Adición de 1 elemento (append)</a></li>\n<li><a href=\"#adici-n-de-2-a-n-elementos--append-\">Adición de 2 a N elementos (append)</a></li>\n<li><a href=\"#fusi-n-de-slices\">Fusión de slices</a></li>\n</ul>\n</li>\n<li><a href=\"#eliminaci-n-de-elementos\">Eliminación de elementos</a>\n<ul>\n<li><a href=\"#shift--eliminaci-n-de-elementos-por-los-extremos-\">Shift (Eliminación de elementos por los extremos)</a></li>\n<li><a href=\"#eliminaci-n-de-elementos-centrales\">Eliminación de elementos centrales</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#mapa\">Mapa</a>\n<ul>\n<li><a href=\"#instanciaci-n-2\">Instanciación</a>\n<ul>\n<li><a href=\"#forma-completa-1\">Forma completa</a></li>\n<li><a href=\"#uso-de-make--\">Uso de make()</a></li>\n</ul>\n</li>\n<li><a href=\"#lectura-de-mapas\">Lectura de mapas</a></li>\n<li><a href=\"#funciones\">Funciones</a></li>\n<li><a href=\"#adici-n-de-valores\">Adición de valores</a></li>\n<li><a href=\"#eliminaci-n-de-elementos-por-clave\">Eliminación de elementos por clave</a></li>\n</ul>\n</li>\n<li><a href=\"#struct\">Struct</a>\n<ul>\n<li><a href=\"#declaraci-n\">Declaración</a>\n<ul>\n<li><a href=\"#declaraci-n-cl-sica\">Declaración clásica</a></li>\n<li><a href=\"#struct-an-nimo\">Struct anónimo</a></li>\n</ul>\n</li>\n<li><a href=\"#instanciaci-n-3\">Instanciación</a>\n<ul>\n<li><a href=\"#manera-normal\">Manera normal</a></li>\n<li><a href=\"#sintaxis-de-posicionamiento\">Sintaxis de posicionamiento</a></li>\n</ul>\n</li>\n<li><a href=\"#composici-n\">Composición</a></li>\n<li><a href=\"#tags\">Tags</a></li>\n<li><a href=\"#convenciones-de-nombres\">Convenciones de nombres</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#constantes\">Constantes</a>\n<ul>\n<li><a href=\"#constantes-enumerados\">Constantes enumerados</a>\n<ul>\n<li><a href=\"#declaraci-n-completa-simple-con-iota\">Declaración completa simple con iota</a></li>\n<li><a href=\"#declaraci-n-simple-con-iota\">Declaración simple con iota</a></li>\n<li><a href=\"#declaraci-n-simple-con-literales\">Declaración simple con literales</a></li>\n<li><a href=\"#multiples-declaraciones-de-bloques-con-iota\">Multiples declaraciones de bloques con iota</a></li>\n<li><a href=\"#usos-del-valor-0-con-iota\">Usos del valor 0 con iota</a></li>\n<li><a href=\"#descartes-de-valores-con-iota\">Descartes de valores con iota</a></li>\n</ul>\n</li>\n<li><a href=\"#convenciones-de-nombre\">Convenciones de nombre</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#scope-de-variables-y-convenci-n-de-nombres-1\">Scope de variables y convención de nombres</a>\n<ul>\n<li><a href=\"#nivel-de-paquete\">Nivel de paquete</a></li>\n<li><a href=\"#nivel-de-funci-n\">Nivel de función</a></li>\n<li><a href=\"#misma-variable-distintos-scope\">Misma variable distintos scope</a></li>\n</ul>\n</li>\n<li><a href=\"#if\">If</a>\n<ul>\n<li><a href=\"#if-b-sico\">If básico</a></li>\n<li><a href=\"#if-avanzado\">If avanzado</a>\n<ul>\n<li><a href=\"#comparadores\">Comparadores</a></li>\n<li><a href=\"#llamadas-a-funciones\">Llamadas a funciones</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#switch\">Switch</a>\n<ul>\n<li><a href=\"#switch-simple\">Switch simple</a></li>\n<li><a href=\"#switch-multiple\">Switch multiple</a></li>\n<li><a href=\"#switch-avanzado\">Switch avanzado</a></li>\n<li><a href=\"#switch-con-condiciones-complejas\">Switch con condiciones complejas</a></li>\n<li><a href=\"#switch-con-fallthrought\">Switch con fallthrought</a></li>\n<li><a href=\"#switch-con-interfaces\">Switch con interfaces</a></li>\n</ul>\n</li>\n<li><a href=\"#for\">For</a></li>\n<li><a href=\"#foreach\">ForEach</a></li>\n<li><a href=\"#labels\">Labels</a>\n<ul>\n<li><a href=\"#breaks\">Breaks</a></li>\n</ul>\n</li>\n<li><a href=\"#defer\">Defer</a>\n<ul>\n<li><a href=\"#usos\">Usos</a>\n<ul>\n<li><a href=\"#problemas\">Problemas</a></li>\n<li><a href=\"#soluciones\">Soluciones</a></li>\n</ul>\n</li>\n<li><a href=\"#llamadas-a-funciones-y-par-metros\">Llamadas a funciones y parámetros</a></li>\n</ul>\n</li>\n<li><a href=\"#panicking\">Panicking</a>\n<ul>\n<li><a href=\"#provocar-panics\">Provocar panics</a></li>\n</ul>\n</li>\n<li><a href=\"#recover\">Recover</a></li>\n<li><a href=\"#punteros\">Punteros</a>\n<ul>\n<li><a href=\"#creaci-n\">Creación</a></li>\n<li><a href=\"#deferenciaci-n\">Deferenciación</a></li>\n</ul>\n</li>\n<li><a href=\"#funciones-1\">Funciones</a>\n<ul>\n<li><a href=\"#convenci-n-de-nombres\">Convención de nombres</a></li>\n<li><a href=\"#par-metros\">Parámetros</a></li>\n<li><a href=\"#punteros-en-par-metros-de-funciones\">Punteros en parámetros de funciones</a>\n<ul>\n<li><a href=\"#vararg\">Vararg</a></li>\n</ul>\n</li>\n<li><a href=\"#return\">Return</a></li>\n<li><a href=\"#funciones-an-nimas\">Funciones anónimas</a>\n<ul>\n<li><a href=\"#simple\">Simple</a></li>\n<li><a href=\"#problema-en-entornos-asincronos\">Problema en entornos asincronos</a></li>\n</ul>\n</li>\n<li><a href=\"#funciones-como-tipos\">Funciones como tipos</a></li>\n<li><a href=\"#m-todos\">Métodos</a></li>\n</ul>\n</li>\n<li><a href=\"#interfaces\">Interfaces</a>\n<ul>\n<li><a href=\"#convenci-n-de-nombres-1\">Convención de nombres</a></li>\n<li><a href=\"#interfaces-de-interfaces\">Interfaces de interfaces</a></li>\n</ul>\n</li>\n</ul>\n<h1>Instalación</h1>\n<h2>Descarga</h2>\n<p><a href=\"https://golang.org/dl/\">https://golang.org/dl/</a></p>\n<h2>Instalación</h2>\n<p>Ejecuta el msi descargado en el caso de windows o descomprime donde quieras si lo prefieres antes que un instalador, asegurate de que sea el cliente de 64 bits</p>\n<h2>Verificación de la instalación</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">go version -> go version go1.17.1 windows/386\r\nwhere go -> C:\\Users\\MaQuiNa1995\\Herramientas\\Go\\bin\\go.exe</code></pre></div>\n<h1>Configuración del entorno</h1>\n<h2>Variables de entorno</h2>\n<h3>Windows</h3>\n<ol>\n<li>GOPATH</li>\n</ol>\n<p>Es la ruta donde tendrás tu Go descargado\r\nValor por defecto: %USERPROFILE%\\go</p>\n<ol start=\"2\">\n<li>PATH</li>\n</ol>\n<p>PATH -> otrasEntradas;%GOPATH%</p>\n<h3>Linux</h3>\n<ol>\n<li>GOPATH</li>\n</ol>\n<p>Es la ruta donde tendrás tu Go descargado\r\nValor por defecto: $HOME/go</p>\n<h3>Verificación</h3>\n<p>Al ejecutar el siguiente comando deberías de obtener una respuesta parecida</p>\n<p>go version -> <code class=\"language-text\">go version go1.17.1 windows/386</code></p>\n<h2>Entorno de desarrollo</h2>\n<p>Como IDE usaremos Visual studio code en el que al entrar te dará la opción de descargar e instalar módulos que puedan sernos útiles como autocompletado y demás</p>\n<p><a href=\"https://az764295.vo.msecnd.net/stable/83bd43bc519d15e50c4272c6cf5c1479df196a4d/VSCodeUserSetup-x64-1.60.1.exe\">Descárgalo aquí desde la página oficial</a></p>\n<p>Cuando lo abrais un pop-up os dará la opción de instalar esos módulos que hablé antes cuando estén todos listos os pondrá en la terminal algo parecido a “you are ready to Go :)”</p>\n<p>Si habeis instalado el cliente de 32 bits de golang tendreis problemas con el analizador de código y no podreis usarle</p>\n<h3>Hola mundo en Visual studio</h3>\n<p>Crearemos un proyecto Golang y del sistema de archivos que nos creará iremos a la carpeta src y crearemos una carpeta adicional será en esta donde crearemos nuestro archivo Main.go con el siguiente contenido</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package main\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc main() {\r\n\tfmt.Println(\"Hola mundo\")\r\n}</code></pre></div>\n<p>Para ejecutar el programa iremos a la vista de la terminal en nuestro visual studio y como este estará ya ubicado en la carpeta de nuestro proyecto\r\nsolo tendremos que ejecutar el siguiente comando</p>\n<p>go run .\\src\\carpetaCreadaPreviamente\\Main.go</p>\n<p>Adicionalmente tambien podeis a una <a href=\"https://play.golang.org/\">consola online</a> y probar allí el mismo código</p>\n<p>Deberíamos de poder ver nuestro hola mundo</p>\n<h1>Zonas básicas En un archivo Go</h1>\n<h2>Paquete</h2>\n<p><code class=\"language-text\">package main</code></p>\n<h2>Import</h2>\n<p>Aqui irían todas las declaraciones de importación sobre librerías de sistema por poner un ejemplo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import (\r\n\t\"fmt\"\r\n\t\"strconv\"\r\n)</code></pre></div>\n<h2>Función Principal</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n    // Aqui iría el código de nuestro punto de entrada al proyecto\r\n}</code></pre></div>\n<h1>Variables</h1>\n<p>En go tenemos diferentes formas de declaración de variables</p>\n<h2>Scope de variables y convención de nombres</h2>\n<ol>\n<li>Pascal case -> Export variables (Variables Globales)</li>\n<li>Camel Case -> internal variables (Variables de paquete)</li>\n</ol>\n<h2>Tipos de datos básicos</h2>\n<p><a href=\"https://golangbyexample.com/all-data-types-in-golang-with-examples/#Basic_Types\">https://golangbyexample.com/all-data-types-in-golang-with-examples/#Basic_Types</a></p>\n<h3>Enteros</h3>\n<h4>Signed int (Enteros)</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Tipo</th>\n<th align=\"center\">Tamaño</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Dependiente De Plataforma</td>\n</tr>\n<tr>\n<td align=\"center\">int8</td>\n<td align=\"center\">8 bits/1 byte</td>\n</tr>\n<tr>\n<td align=\"center\">int16</td>\n<td align=\"center\">16 bits/2 byte</td>\n</tr>\n<tr>\n<td align=\"center\">int32</td>\n<td align=\"center\">32 bits/4 byte</td>\n</tr>\n<tr>\n<td align=\"center\">int64</td>\n<td align=\"center\">64 bits/8 byte</td>\n</tr>\n</tbody>\n</table>\n<h4>Unsigned int (Enteros)</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Tipo</th>\n<th align=\"center\">Tamaño</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">uint</td>\n<td align=\"center\">Dependiente De Plataforma</td>\n</tr>\n<tr>\n<td align=\"center\">uint8</td>\n<td align=\"center\">8 bits/1 byte</td>\n</tr>\n<tr>\n<td align=\"center\">uint16</td>\n<td align=\"center\">16 bits/2 byte</td>\n</tr>\n<tr>\n<td align=\"center\">uint32</td>\n<td align=\"center\">32 bits/4 byte</td>\n</tr>\n<tr>\n<td align=\"center\">uint64</td>\n<td align=\"center\">64 bits/8 byte</td>\n</tr>\n</tbody>\n</table>\n<h3>Decimales</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Tipo</th>\n<th align=\"center\">Tamaño</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">float32</td>\n<td align=\"center\">32 bits or 4 bytes</td>\n</tr>\n<tr>\n<td align=\"center\">float64</td>\n<td align=\"center\">64 bits or 8 bytes</td>\n</tr>\n</tbody>\n</table>\n<h3>Números complejos</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Tipo</th>\n<th align=\"center\">Tamaño</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">complex64</td>\n<td align=\"center\">Parte real e imaginaria son float32</td>\n</tr>\n<tr>\n<td align=\"center\">complex128</td>\n<td align=\"center\">Parte real e imaginaria son float64</td>\n</tr>\n</tbody>\n</table>\n<p>El tipo complejo por defecto es complex128</p>\n<h3>Byte</h3>\n<p>byte es un alias para uint8 vamos que se considera un valor entero de 8 bits y representa un byte (0-255) este a su vez puede representar un caracter ASCII Golang no tiene un tipo char aluso como por ejemplo Java</p>\n<h3>Rune</h3>\n<p>rune es un alias para int32 por lo tanto se le considera un entero se usa para representar un <strong>Unicode Code Point</strong></p>\n<p>Unicode es un superconjunto de caracteres ASCII que asigna un número único a cada carácter que existe. Este número único se llama <strong>Unicode Code Point</strong></p>\n<p>Algunos ejemplos:</p>\n<ol>\n<li>El dígito 0 se representa como punto Unicode U+0030 (valor decimal – 48)</li>\n<li>La letra pequeña b se representa como punto Unicode U+0062 (valor decimal – 98)</li>\n<li>Un símbolo de libra £ se representa como Punto Unicode U+00A3 (Valor decimal – 163)</li>\n</ol>\n<p>Puedes aprender mas sobre esto en:\r\n<a href=\"http://www.joelonsoftware.com/articles/Unicode.html\">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets</a></p>\n<h3>UTF-8</h3>\n<p>utf-8 guarda cada Unicode Code Point utilizando 1, 2, 3 o 4 bytes.</p>\n<p>Los puntos ASCII se almacenan utilizando 1 byte. Es por eso que rune es un alias para int32 porque un Unicode Code Point puede ser de un máximo de 4 bytes en Go, ya que cada cadena está codificada usando utf-8 cada rune está destinada a referirse a un Unicode Code Point.</p>\n<p>Por ejemplo, si imprime una cadena después de encasillarla en una matriz de runes, imprimirá el Unicode Code Point para cada uno de los caracteres.\r\nPara la siguiente cadena “0b£” la salida será – [U+0030 U+0062 U+00A3]</p>\n<h3>String</h3>\n<p>En go se puede declarar una String con comillas simples y con comillas dobles</p>\n<h3>Booleanos</h3>\n<p>Pueden tomar o true o false\r\nPor defecto su valor es false</p>\n<h4>Operadores lógicos</h4>\n<ol>\n<li>AND –> &#x26;&#x26;</li>\n<li>OR  –> ||</li>\n<li>Negación –> !</li>\n</ol>\n<h2>Inicializaciones</h2>\n<h3>Inicialización Completa</h3>\n<p><code class=\"language-text\">var numero int = 1</code></p>\n<h3>Inicialización Tardía</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var numero3 int\r\nnumero3 = 3</code></pre></div>\n<h3>Inicialización Abreviada (Type Inference)</h3>\n<p><code class=\"language-text\">numero2 := 2</code></p>\n<p>El único problema de esta forma de declaración es que cuando, por ejemplo tenemos <code class=\"language-text\">numero2 := 2.</code> que representaría un número decimal, es que nos inicializa la variable con <strong>float64</strong> no hay ninguna forma de crear un <strong>float32</strong> por esta vía</p>\n<h3>Inicialización múltiple</h3>\n<p>Podemos como en otros lenguajes usar la asignación múltiple con cualquier de las 3 formas anteriores</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var nombre, github string = \"MaQuiNa\", \"https://github.com/MaQuiNa1995\"\r\nnumero, numero2 := 1, 2</code></pre></div>\n<h2>Colecciones</h2>\n<h3>Arrays</h3>\n<h4>Instanciación</h4>\n<h5>Forma Completa</h5>\n<p><code class=\"language-text\">profesiones := [3]string{\"Caballero Cebolla\", \"Ilusionista\", \"Francotirador\"}</code></p>\n<p>En esta forma se inicializa de manera completa el array declarando el tamaño y los elementos que lo conforman</p>\n<h5>Forma Elegante</h5>\n<p><code class=\"language-text\">profesiones2 := [...]string{\"Caballero Cebolla\", \"Ilusionista\", \"Francotirador\"}</code></p>\n<p>Esta forma es equivalente a la anterior solo que omitiendo el tamaño ya que en este caso resulta dedundante ya que tenemos 3 elementos</p>\n<p>Hay casos en los que no deberías de utilizar esta forma ya que tendrías que ir 1 a 1 contando manualmente los elementos entre { } entonces solo eligiría esta manera si es visualmente muy fácil saber cuentos elementos conforman el array</p>\n<h5>Declaración Tardía</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var profesiones3 [3]string\r\nprofesiones3[0] = \"Caballero Cebolla\"\r\nprofesiones3[1] = \"Ilusionista\"\r\nprofesiones3[2] = \"Francotirador\"</code></pre></div>\n<p>En esta forma dejamos la declaración de los elementos para “mas tarde”</p>\n<p>Como dato adicional</p>\n<ol>\n<li>Aqui no se pueden usar los […] que utilizamos en la anterior forma</li>\n<li>Se pueden dejar posiciones vacías en cuyo caso dependiendo del tipo de objeto cogerían el valor por defecto</li>\n</ol>\n<h4>Punteros en Arrays</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := [...]string{\"Caballero Cebolla\", \"Ilusionista\", \"Francotirador\"}\r\nprofesionesCopia := profesiones\r\nprofesionesCopia[0] = \"Mago Azul\"\r\nfmt.Printf(\"Profesiones:       %v\\nProfesiones Copia: %v\\n\", profesiones, profesionesCopia)</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Profesiones:       [Caballero Cebolla Ilusionista Francotirador]\r\nProfesiones Copia: [Mago Azul Ilusionista Francotirador]</code></pre></div>\n<p>En Go cada “copia” ya sea por asignación o por el envío de estos a una función genera una nueva copia de estos, en otros lenguajes siempre se apunta a la misma dirección de memoria y si modificas uno el otro tambien se ve afectado, en Go no es asi siempre se crea uno nuevo a no ser que hagas lo siguiente</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := [...]string{\"Caballero Cebolla\", \"Ilusionista\", \"Francotirador\"}\r\nprofesionesCopia := &amp;profesiones\r\nprofesionesCopia[0] = \"Domador\"\r\nfmt.Printf(\"Profesiones:       %v\\nProfesiones Copia: %v\\n\", profesiones, profesionesCopia)</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Profesiones:       [Domador Ilusionista Francotirador] \r\nProfesiones Copia: &amp;[Domador Ilusionista Francotirador]</code></pre></div>\n<p>Con el modificador &#x26; en la asignación le decimos a go que los dos arrays apunten a la misma dirección de memoria por lo tanto si modificas uno, el otro tambien se ve afectado</p>\n<h4>Punteros en Arrays</h4>\n<p>Si recuerdas de los arrays si no usábamos el operador <code class=\"language-text\">&amp;</code> no provocabamos que 2 variables apuntasen al mismo hueco de memoria en los slice esto siempre es asi de tal manera que si cambiamos una slice el otro tambien se verá afectado, un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := []string{\"Caballero Cebolla\", \"Ilusionista\", \"Francotirador\"}\r\nprofesionesCopia := profesiones\r\nprofesionesCopia[0] = \"Alquimista\"\r\nfmt.Printf(\"Profesiones:       %v\\nProfesiones Copia: %v\\n\", profesiones, profesionesCopia)</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Profesiones:       [Alquimista Ilusionista Francotirador]\r\nProfesiones Copia: [Alquimista Ilusionista Francotirador]</code></pre></div>\n<h3>Slices</h3>\n<p>Los slice son y tienen la misma funcionalidad que un array con alguna que otra excepción que luego veremos</p>\n<h4>Instanciación</h4>\n<h5>Forma completa</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sliceOriginal := []int{1, 2, 3, 4, 5}\r\nfmt.Printf(\"Slice Original: %v\\n\", sliceOriginal)</code></pre></div>\n<h5>Copia de un slice</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice2 := sliceOriginal[:]\r\nfmt.Printf(\"Slice Copia de Slice Original: %v\\n\", slice2)</code></pre></div>\n<h5>Copia de un Slice con cortes</h5>\n<p>Una regla que siguen las siguientes formas dependiendo donde esté el número a la derecha o izquierda o en ambos de <code class=\"language-text\">:</code> Inclusivo:Exclusivo</p>\n<p>Tambien decir que está nomenclatura tambien se aplica a <code class=\"language-text\">Arrays</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice3 := sliceOriginal[3:]  //Se descartan los 3 primeros valores de sliceOriginal\r\nslice4 := sliceOriginal[:4]  // Se cogen solo los 4 primeros elementos de sliceOriginal\r\nslice5 := sliceOriginal[2:4] // Se descartan los 2 primeros elementos y se obtienen los siguientes elementos (despues del primer descarte) hasta la posicion X del slice original\r\n\r\nfmt.Printf(\"Slice Cortado con principio definido: %v\\n\", slice3)\r\nfmt.Printf(\"Slice Cortado desde el inicio hasta un final definido: %v\\n\", slice4)\r\nfmt.Printf(\"Slice Cortado descartando X elementos y seleccionado Y de los primeros restantes: %v\", slice5)</code></pre></div>\n<h5>Uso de make para la instanciación de slices</h5>\n<p>Podemos usar 2 argumentos</p>\n<ol>\n<li>tipo -> []int</li>\n<li>Tamaño -> 4</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := make([]int, 4)\r\nfmt.Println(slice)\r\nfmt.Printf(\"Tamaño: %v\\n\", len(slice))\r\nfmt.Printf(\"Capacidad: %v\\n\", cap(slice))</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0 0 0 0]\r\nTamaño: 4\r\nCapacidad: 4</code></pre></div>\n<p>Tambien podemos usar 3 argumentos</p>\n<ol>\n<li>tipo -> []int</li>\n<li>Tamaño -> 4</li>\n<li>Capacidad -> 4</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice2 := make([]int, 4, 10)\r\nfmt.Println(slice2)\r\nfmt.Printf(\"Tamaño: %v\\n\", len(slice2))\r\nfmt.Printf(\"Capacidad: %v\", cap(slice2))</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0 0 0 0]   \r\nTamaño: 4   \r\nCapacidad: 10</code></pre></div>\n<h4>Funciones de los Slice</h4>\n<p>Podemos añadir y quitar elementos de un slice dinámicamente a diferencia de un array no tiene un tamaño predefinido</p>\n<h5>Adición de 1 elemento (append)</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{}\r\nfmt.Println(slice)\r\nfmt.Printf(\"Tamaño: %v\\n\", len(slice))\r\nfmt.Printf(\"Capacidad: %v\\n\", cap(slice))\r\n\r\nslice = append(slice, \"Mago del Tiempo\") // Tenemos que igualarlo al slice \r\nfmt.Println(slice)\r\nfmt.Printf(\"Tamaño: %v\\n\", len(slice))\r\nfmt.Printf(\"Capacidad: %v\\n\", cap(slice))</code></pre></div>\n<p>A tener muy en cuenta: cuando un slice tiene capacidad 2 y tamaño 2 (Osea está lleno) y metemos un nuevo elemento la capacidad del slice se doblará en el caso de que el slice fuese su capacidad de 0 pasará a 2</p>\n<p>Con el siguiente ejemplo se ve muy claro:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{\"Mago del Tiempo\", \"Monje\"}\r\nfmt.Println(slice)\r\nfmt.Printf(\"Tamaño: %v\\n\", len(slice))\r\nfmt.Printf(\"Capacidad: %v\\n\", cap(slice))\r\n\r\nslice = append(slice, \"Paladín\")\r\nfmt.Println(slice)\r\nfmt.Printf(\"Tamaño: %v\\n\", len(slice))\r\nfmt.Printf(\"Capacidad: %v\\n\", cap(slice))</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Mago del Tiempo Monje]\r\nTamaño: 2\r\nCapacidad: 2\r\n[Mago del Tiempo Monje Paladín]\r\nTamaño: 3\r\nCapacidad: 4 // la capacidad se ha doblado</code></pre></div>\n<h5>Adición de 2 a N elementos (append)</h5>\n<p>Se pueden añadir de 2 a mas elementos a un slice añadiendo en el append mas argumentos:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{\"Mago del Tiempo\", \"Monje\"}\r\nslice = append(slice, \"Paladín\",\"Soldado\",\"Dragontino\")</code></pre></div>\n<h5>Fusión de slices</h5>\n<p>Podemos fusionar slices ya sea por variable o porque se ha instanciado directamente uno en el propio append</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{\"Mago del Tiempo\", \"Monje\"}\r\nslice2 := []string{\"Paladín\", \"Soldado\", \"Dragontino\"}\r\n\r\nslice = append(slice, slice2...)                         // Fusión por variable\r\nslice = append(slice, []string{\"Domador\", \"Cazador\"}...) // fusión por slice instanciado</code></pre></div>\n<h4>Eliminación de elementos</h4>\n<p>Se pueden elemininar elementos de un slice de distintas maneras</p>\n<h5>Shift (Eliminación de elementos por los extremos)</h5>\n<p>Con esta técnica crearíamos un nuevo array omitiendo valores del slice original</p>\n<p>Cortar por el principio</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{\"Mago del Tiempo\", \"Monje\"}\r\n// Crearíamos un nuevo slice omitiendo el primer elemento de \"slice\"\r\nslice2 := slice[1:]</code></pre></div>\n<p>Cortar por el final</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{\"Mago del Tiempo\", \"Monje\"}\r\n// Crearíamos un nuevo slice omitiendo el último elemento del original\r\nslice2 := slice[:len(slice)-1]</code></pre></div>\n<h5>Eliminación de elementos centrales</h5>\n<p>Aqui las cosas se ponen un poco espinosas teniendo que hacer nuevos slices de las partes del slice original, se ve mejor visualmente con un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []string{\"Mago del Tiempo\", \"Monje\", \"Paladín\", \"Elementalista\", \"Esgrimista\"}\r\n\r\n// Crearíamos un nuevo slice omitiendo el último elemento del original\r\n// slice[:2] -> crea un array con: Mago del Tiempo Monje\r\n// slice[4:]... -> añade a ese array creado los elementos resultantes de descartar 4 elementos del slice original\r\nslice2 := append(slice[:2], slice[4:]...)\r\n\r\n// imprime: [Mago del Tiempo Monje Esgrimista]\r\n// se han eliminado los elementos centrales: Paladín y Elementalista\r\nfmt.Print(slice2)</code></pre></div>\n<h3>Mapa</h3>\n<p>Consiste en un par de valores primero la key y luego el value ambos pueden tener cualquier tipo</p>\n<p>A tener en cuenta los mapas apuntan siempre a la misma referencia asique si lo pasamos a una función y manipulamosese mapa fuera de la función ese objeto tambien se verá afectado por los cambios</p>\n<h4>Instanciación</h4>\n<h5>Forma completa</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// map[tipo de la key] tipo del value\r\nprofesiones := map[int]string{\r\n\t1: \"Soldado\",\r\n\t2: \"Paladín\",\r\n\t3: \"Dragontino\",\r\n\t4: \"Lancero\",\r\n}\r\nfmt.Println(profesiones)</code></pre></div>\n<h5>Uso de make()</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones2 := make(map[int]string)\r\nfmt.Println(profesiones2)</code></pre></div>\n<h4>Lectura de mapas</h4>\n<p>Se suelen hacer por key para obtener el value de tal manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := map[int]string{\r\n\t675: \"Soldado\",\r\n\t432: \"Paladín\",\r\n\t321: \"Dragontino\",\r\n\t968: \"Lancero\",\r\n}\r\n// no imprimiría nada ya que no existe ninguna key que valga 3\r\nfmt.Println(profesiones[3]) \r\n// En cambio esto si que imprimiría Dragontino porque el valor 321 existe de key\r\nfmt.Println(profesiones[321])</code></pre></div>\n<p>Tenemos otra forma de leer entradas de un mapa leyendo directamente el par o la key del  mismo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := map[int]string{\r\n\t675: \"Soldado\",\r\n\t432: \"Paladín\",\r\n\t321: \"Dragontino\",\r\n\t968: \"Lancero\",\r\n}\r\ntrabajo, ok := profesiones[675]\r\n// \t    \tSoldado true\r\nfmt.Println(trabajo, ok)\r\ntrabajo2, ok2 := profesiones[999]\r\n//                    false\r\nfmt.Println(trabajo2, ok2)</code></pre></div>\n<p>trabajo -> value del mapa\r\nok -> booleano indicando la existencia en el mapa de esa key (<code class=\"language-text\">profesiones[key]</code>)</p>\n<p>En el caso de que solo pongamos uno de los 2 sacaríamos el value de esa key</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">trabajo := profesiones[675]\r\nfmt.Println(trabajo)</code></pre></div>\n<p>Tambien podemos descartar el valor y quedarnos con el booleano de si existe o no:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">_ , ok := profesiones[675]\r\nfmt.Println(ok)</code></pre></div>\n<p>A tener en cuenta si sacamos algo que no existe:\r\nkey -> el valor por defecto (String = ” ” y numeros = 0)\r\nvalue -> false</p>\n<h4>Funciones</h4>\n<p>como en los arrays aqui tambien tenemos la función len() para ver el tamaño del mapa</p>\n<h4>Adición de valores</h4>\n<p>Podemos añadir valores como se puede observar aqui:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := map[int]string{\r\n\t675: \"Soldado\",\r\n\t432: \"Paladín\",\r\n\t321: \"Dragontino\",\r\n\t968: \"Lancero\",\r\n}\r\n// No sacaría nada\r\nfmt.Println(profesiones[6])\r\nprofesiones[6] = \"Samurai\"\r\n// Imprimiría Samurai ya que ahora si está en el mapa\r\nfmt.Println(profesiones[6])</code></pre></div>\n<p>Una cosa al tener en cuenta es que cuando añadimos un elemento el mapa puede cambiar totalmente la ordenación</p>\n<h4>Eliminación de elementos por clave</h4>\n<p>Podemos usar la funcion delete para eliminar entradas del mapa por id, un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := map[int]string{\r\n\t675: \"Soldado\",\r\n\t432: \"Paladín\",\r\n\t321: \"Dragontino\",\r\n\t968: \"Lancero\",\r\n}\r\n// mapa , id de la entrada a eliminar\r\ndelete(profesiones, 432)\r\nfmt.Println(profesiones)</code></pre></div>\n<h3>Struct</h3>\n<p>Viene a referirse a objetos en la vida cotidiana, lo que vendría siendo una clase en java por ejemplo</p>\n<p>Copias de ese struct no apuntan a la misma referencia por lo que si cambias una la otra no se ve afectada para que sean iguales debemos usar ”&#x26;” para indicar que esas 2 variables aputan a la misma referencia, es tal cual se hace en Arrays</p>\n<h4>Declaración</h4>\n<p>Debemos tener los struct a nivel de paquete</p>\n<h5>Declaración clásica</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Tecnica struct {\r\n\tnivelRequerido int\r\n\tnombre         string\r\n\tmana           int\r\n}</code></pre></div>\n<h5>Struct anónimo</h5>\n<p>Se puede declarar un struct directamente en una función</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tecnica := struct{ nivelRequerido int }{nivelRequerido: 50}\r\nfmt.Print(tecnica)</code></pre></div>\n<h4>Instanciación</h4>\n<h5>Manera normal</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tecnica := Tecnica{\r\n\tnivelRequerido: 10,\r\n\tnombre:         \"Última Pesadilla\",\r\n\tmana:           40,\r\n}\r\nfmt.Print(tecnica)               // Si queremos consultar todos los valores del struct\r\nfmt.Print(\"\\n\" + tecnica.nombre) // Si queremos consultar un valor en específico</code></pre></div>\n<h5>Sintaxis de posicionamiento</h5>\n<p>Hay otra manera de instanciar un struct eliminando los nombres de los campos en este cada atributo corresponde exactamente a la posicion de los campos del struct a esta técnica se le llama “Positional Syntax”</p>\n<p>no es recomendable su uso por razones de mantenibilidad ya que si cambias el orden de los campos o añades otro lo vas a tener dificil para mantenerlo</p>\n<p>un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tecnica := Tecnica{\r\n\t10,                 // Corresponde con la 1º posición del struct nivelRequerido\r\n\t\"Última Pesadilla\", // nombre\r\n\t40,                 //mana\r\n}</code></pre></div>\n<h4>Composición</h4>\n<p>En go no existe la herencia pero tenemos algo parecido usaremos el “embedding”</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Magia struct {\r\n\tmana int\r\n}\r\n\r\ntype MagiaNegra struct {\r\n\tMagia\r\n\tdanno int\r\n}\r\n\r\nfunc main() {\r\n\tmagiaNegra := MagiaNegra{}\r\n\tmagiaNegra.mana = 10\r\n\tmagiaNegra.danno = 500\r\n\t// {{10} 500}\r\n\tfmt.Println(magiaNegra)\r\n\t// 10\r\n\tfmt.Println(magiaNegra.mana)\r\n\t// 500\r\n\tfmt.Println(magiaNegra.danno)\r\n}</code></pre></div>\n<p>En otros lenguajes tradicionales tendríamos una herencia de magia negra con magia, pero en Go tendríamos que embeber Magia dentro de Magia negra</p>\n<h4>Tags</h4>\n<p>Los tags son usados para añadir constraints o limitaciones esto no actua directamente sobre el struct sino que es usado por frameworks de terceros o uno custom que haga uso de esa información para cierto fin usando el paquete de reflection</p>\n<p>Básicamente es añadir metadatos a los campos de un struct para un framework ya sea de terceros o custom use esa información para validar algo o saber como des-serializar un json xml etc</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Tecnica struct {\r\n\tnivelRequerido int\r\n\tnombre         string `required,max:\"10\"`\r\n\tmana           int\r\n}\r\n\r\nfunc main() {\r\n\ttecnicaReflection := reflect.TypeOf(Tecnica{})\r\n\tcampo, _ := tecnicaReflection.FieldByName(\"nombre\")\r\n\t// required,max:\"10\"\r\n\tfmt.Print(campo.Tag)\r\n}</code></pre></div>\n<h4>Convenciones de nombres</h4>\n<p>Al igual que las variables si ponemos mayúscula la primera letra querrá decir que están expuestas a toda la aplicación pero en cambio si está en minúscula estará disponible a nivel de paquete solamente, usaremos pascal naming</p>\n<h2>Constantes</h2>\n<p>Van precedidas de la palabra const</p>\n<ol>\n<li><code class=\"language-text\">const constante string = \"constante\"</code></li>\n<li><code class=\"language-text\">const constante = \"constante\"</code></li>\n</ol>\n<p>Como dato curioso en otros lenguajes tipo java puedes tener asignacioens de constantes que dependan en la ejecución de una función por ejemplo es decir que se resuelvan en tiempo de ejecución , en Golang eso no se puede pero sin embargo las operaciones matemáticas entre literales o constantes si que están permitidas</p>\n<p>A nivel de compilador:</p>\n<ol>\n<li>Son inmutables puede aplicarse el “shadow”</li>\n<li>Son reemplazadas por el compilador en tiempo de compilación</li>\n<li>El valor debe poder ser calculado en tiempo de compilación</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const(\r\n\tnumero1 = 1\r\n\tnumero2 = 2\r\n\tnumero3 = numero1 + numero2 // valdría 3\r\n)</code></pre></div>\n<p>Y como último dato importante no se puede hacer una constante de una <strong>colección</strong>, estos <strong>siempre serán variables</strong></p>\n<h3>Constantes enumerados</h3>\n<p>Suelen ir a nivel de paquete y mas raramente a nivel de función (aunque no deberías)</p>\n<h4>Declaración completa simple con iota</h4>\n<p>puedes usar a nivel de paquete la siguiente forma de declarar una enumeracion de constantes</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\tconstanteEnumerada  = iota // valdría 0\r\n\tconstanteEnumerada2 = iota // valdría 1\r\n\tconstanteEnumerada3 = iota // valdría 2\r\n)</code></pre></div>\n<p>En este caos al usar iota este actua como un contador que empieza desde 0 y va incrementando su valor en 1</p>\n<h4>Declaración simple con iota</h4>\n<p>Si quitamos el iota de la constante 2 y 3 tendríamos el mismo resultado ya que el compilador de go asigna a las constantes que no están inicializadas explicitamente el ultimo valor seteado de tal manera</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\tconstanteEnumerada  = iota // valdría 0\r\n\tconstanteEnumerada2        // valdría 1\r\n\tconstanteEnumerada3        // valdría 2\r\n)</code></pre></div>\n<h4>Declaración simple con literales</h4>\n<p>Ahora si en vez de usar iota usamos un literal todas las constantes por debajo de esa tendrán ese valor hasta que se setee otro literal de tal manera</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\tconstanteEnumerada = 1  // Valdría 1\r\n\tconstanteEnumerada2     // Valdría 1\r\n\tconstanteEnumerada3 = 2 // Valdría 2\r\n\tconstanteEnumerada4     // Valdría 2\r\n)</code></pre></div>\n<h4>Multiples declaraciones de bloques con iota</h4>\n<p>Ahora bien si tenemos por ejemplo 2 bloques de constantes y usamos iota en los 2 iota el valor se reiniciara para cada bloque (Osea que el scope de iota esta ligado a cada bloque de constantes ) de tal manera</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\tconstanteEnumerada = iota  // valdría 0\r\n\tconstanteEnumerada2        // valdría 1\r\n)\r\n\r\nconst (\r\n\tconstanteEnumerada3 = iota // valdría 0\r\n)</code></pre></div>\n<p>Recuerda que las operacioens matemáticas entre constantes o literales están permitidas asique podríamos hacer algo parecido a esto</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\tconstanteEnumerada = iota + 5  // valdría 5\r\n\tconstanteEnumerada2            // valdría 6 \r\n)</code></pre></div>\n<p>o algo un poco mas útil sería aprobechar esa funcionlidad para hacer potencias a traves del operador bitwise (&#x3C;&#x3C;) como dijimos antes no se pueden llamar a funciones y en Go para hacer el tema de potencias necesitas usar la librería de math por lo tanto para poder hacer potencias tendríamos algo como esto:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\t_  = iota\r\n\tKB = 1 &lt;&lt; (10 * iota) // Con esto conseguimos una potencia 10^1\r\n\tMB\t\t\t\t\t  // Con esto conseguimos una potencia 10^2 etc\r\n\tGB\r\n\tTB\r\n\tPB\r\n\tEB\r\n\tZB\r\n\tYB\r\n)\r\n\r\nfunc main() {\r\n\t// Aqui tenemos un decimal que representa el peso de un fichero\r\n\tfileSize := 4000000000.\r\n\t/*\r\n\t\tCon el Printf aplicamos cierto formato\r\n\t\t%.2f -> decimal de precisión 2\r\n\t\tconcatenado con \" GB\"\r\n\t*/\r\n\tfmt.Printf(\"%.2f GB\", fileSize/GB) // Imprime 3.73 GB\r\n}</code></pre></div>\n<p>Tambien podrías usar los operadores Shift (>>)</p>\n<h4>Usos del valor 0 con iota</h4>\n<p>Un buen caso para usar las constantes enumeradas sería:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\tespecialistaError = iota\r\n\tespecialistaGato\r\n\tespecialistaPerro\r\n\tespecialistaHamster\r\n)\r\n\r\nfunc main() {\r\n\tvar tipoEspecialista int\r\n\tfmt.Println(tipoEspecialista == especialistaError) // True\r\n\r\n\ttipoEspecialista = 1\r\n\tfmt.Println(tipoEspecialista == especialistaGato) // True\r\n\r\n}</code></pre></div>\n<h4>Descartes de valores con iota</h4>\n<p>podemos descartar un valor generado por iota usando <code class=\"language-text\">_</code> un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\t_ = iota\t\t\t// Descartamos el valor 0\r\n\tespecialistaGato\t// Valdría 1\r\n\tespecialistaPerro\t// Valdría 2\r\n\tespecialistaHamster // Valdría 3\r\n)\r\n\r\nfunc main() {\r\n\ttipoEspecialista := 1\r\n\tfmt.Println(tipoEspecialista == especialistaGato) // True\r\n}</code></pre></div>\n<p>Podemos descartar multiples valores</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const (\r\n\t_                = iota // Descartamos el valor 0\r\n\t_                = iota // Descartamos el valor 1\r\n\tespecialistaGato        // Valdría 2\r\n)</code></pre></div>\n<p>En el que para verificar que una constante no está inicializada usamos la constante <code class=\"language-text\">especialistaError</code> que vale 0</p>\n<h3>Convenciones de nombre</h3>\n<p>En otros lengajes verías nombres parecido a esto: CONSTANTE_PI sin embargo en go la convención es la misma que con las variables para el mismo caso en go sería constantePi si queremos que solo sea accesible desde ese paquete o ConstantePi para que sea accesible globalmente (esto aplicado a variables a nivel de paquete las de nivel de función serían con minúscula siempre)</p>\n<h1>Scope de variables y convención de nombres</h1>\n<ol>\n<li>Pascal case -> Export variables (Variables Globales)</li>\n<li>Camel Case -> internal variables (Variables de paquete)</li>\n</ol>\n<h2>Nivel de paquete</h2>\n<p>En go las variables que estén a nivel de paquete</p>\n<ol>\n<li>Si empiezan por mayúscula -> <code class=\"language-text\">var Numero int 5</code> serán accesibles por todos</li>\n<li>Si empiezan por minúscula -> <code class=\"language-text\">var numero int 5</code> será accesible solo en ese paquete</li>\n<li>Capitalización de acrónimos -> si usamos algún acrónimo este debe estar en mayúscula var direccionHTTP string = ”<a href=\"http://localhost:25565\">http://localhost:25565</a>”</li>\n</ol>\n<h2>Nivel de función</h2>\n<p>En go las variables de función solo estarán disponibles para los miembros de la misma función y si una variable se llama de la misma forma que una a nivel de paquete, la que está a nivel de función será la que se use (a esto se le llama Shadow que explicaremos en mas detalle en el siguiente apartado)</p>\n<p>Esto no solo aplica a los nombres sino tambien al tipo</p>\n<h2>Misma variable distintos scope</h2>\n<p>En go se puede tener distintas variables con el mismo nombre siempre que estas estén en distintos scope el orden de preferencia que tiene Go sobre esto cuando por ejemplo lees el valor de una variable es que en este caso concreto la variable mas cercana coge precendencia</p>\n<p>Imagínate que tienes:</p>\n<ol>\n<li>Una variable numero con valor 0 a nivel de paquete</li>\n<li>Otra que se llame igual con valor 2 a nivel de función</li>\n</ol>\n<p>si por ejemplo en esa función lees el valor de numero el orden de preferencia hace que leas el valor 2 ya que está mas cercana (de hecho está en el mismo bloque) a esto se le llama “variable shadowning”</p>\n<p>Por resumir y que quede claro el shadowning es cuando tenemos la misma variable en distintos scopes entonces la forma de determinar con cual vamos a interactuar es la que mas cercana esté a donde se está usando por ejemplo un <code class=\"language-text\">fmt.Println(numero)</code></p>\n<p>Con esta técnica tambien se puede hacer “shadow” a un tipo de las variables de distintos scopes de la misma forma que de los valores</p>\n<h1>If</h1>\n<h2>If básico</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if condicion {\r\n\tfmt.Print(\"La condicion es afirmativa\")\r\n} else if condicion &amp;&amp; otraCondicion {\r\n\tfmt.Print(\"Las 2 condiciones son afirmativas\")\r\n} else {\r\n\tfmt.Print(\"La condicion es negativa\")\r\n}</code></pre></div>\n<h2>If avanzado</h2>\n<p>Podemos usar un return de varios valores en la condición y usarlo tanto dentro del if como en la condición como por ejemplo la variable ok que dictamina si la key con valor <code class=\"language-text\">675 -> osea la variable id</code> está en el mapa <code class=\"language-text\">profesiones</code></p>\n<p>Luego dento del if usamos la variable trabajo que lleva el valor de la key con valor 675 en el mapa</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := map[int]string{\r\n\t675: \"Soldado\",\r\n\t432: \"Paladín\",\r\n\t321: \"Dragontino\",\r\n\t968: \"Lancero\",\r\n}\r\n\r\nid := 675\r\nif trabajo, ok := profesiones[id]; ok {\r\n\tfmt.Printf(\"Trabajo con id: %v y value: %v\", id, trabajo)\r\n}</code></pre></div>\n<h3>Comparadores</h3>\n<p>En Go se pueden usar todos operadores habituales de la programación <code class=\"language-text\">&amp; | &lt; > ==</code></p>\n<h3>Llamadas a funciones</h3>\n<p>En go las condiciones tambien pueden ser el return de una función</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\r\n\tif createCondition() == false {\r\n\t\tfmt.Print(\"La condición es falsa\")\r\n\t}\r\n}\r\n\r\nfunc createCondition() bool {\r\n\tfmt.Print(\"Retornando condición\")\r\n\treturn true\r\n}</code></pre></div>\n<h1>Switch</h1>\n<p>Los statements que pueden ir dentro y por lo tanto se ejecutarian en cada case pueden ser de 0 a N de tal manera podríamos tener mas de 1 statement en un case un ejemplo muy simple</p>\n<p>Tambien podemos hacer uso de break si por cualquier razón en un caso específico no queremos ejecutar cierta parte del switch poniendo un <code class=\"language-text\">break</code> en el ejemplo no va a tener mucho sentido pero esto junto a un if por ejemplo si que podría llegar a tener sentido</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">switch {\r\ncase 1:\r\n\tfmt.Print(\"Puedo tener mas de 1 statement entre cases\")\r\n\tfmt.Print(\"Y pertenecerían al mismo case en este caso del valor numero > 0\")\r\n\tbreak\r\n\tfmt.Print(\"Esto o se ejecuta ya que esta debajo de un break\")</code></pre></div>\n<h2>Switch simple</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numero := 1\r\nswitch numero {\r\n\r\ncase 1:\r\n\tfmt.Print(\"Uno\")\r\ncase 2:\r\n\tfmt.Print(\"Dos\")\r\ndefault:\r\n\tfmt.Print(\"Ni 1 ni 2\")\r\n}</code></pre></div>\n<h2>Switch multiple</h2>\n<p>Podemos concatenar condiciones en un mismo case</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numero := 1\r\nswitch numero {\r\ncase 1, 2:\r\n\tfmt.Print(\"Uno o Dos\")\r\ndefault:\r\n\tfmt.Print(\"Ni 1 ni 2\")\r\n}</code></pre></div>\n<p>A tener en cuenta que en los switch no puede haber valores duplicados es decir que 2 cases distintos tengan el mismo valor te daría un syntax error</p>\n<h2>Switch avanzado</h2>\n<p>Al igual que con los if podemos definir una variable dentro del switch directamente y evaluar ese resultado</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Definimos una variable directamente en el switch y calculamos su valor ->  2 + 1 = 3\r\nswitch suma := 2 + 1; suma {\r\ncase 1, 2:\r\n\tfmt.Print(\"Uno o Dos\")\r\ndefault:\r\n\tfmt.Print(\"Ni 1 ni 2\")\r\n}</code></pre></div>\n<h2>Switch con condiciones complejas</h2>\n<p>Podemos usar condiciones complejas en nuestros cases un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numero := 0\r\nswitch {\r\ncase numero > 0:\r\n\tfmt.Print(\"Mayor que cero\")\r\ncase numero &lt; 0:\r\n\tfmt.Print(\"Menor que cero\")\r\ndefault:\r\n\tfmt.Print(\"Es cero\")\r\n}</code></pre></div>\n<p>en este tipo de switch los cases pueden hacer overlapping ya que puede que 2 cases sean true para cierta condición en estos casos el que antes de evalúe tiene preferencia sobre el resto</p>\n<h2>Switch con fallthrought</h2>\n<p>A diferencia de java no hay falltrought de manera por defecto, tenemos que indicarlo a traves de <code class=\"language-text\">fallthrough</code> al final de los statement del case</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numero := 1\r\n\r\nswitch {\r\ncase numero > 0:\r\n\tfmt.Println(\"Uno\")\r\n\t// Esto haría que se ejecutase el siguiente case aunque el mismo sea false\r\n\tfallthrough\r\ncase numero > 5: // Esto es false ya que numero es = 1\r\n\tfmt.Println(\"Cinco\")\r\ndefault:\r\n\tfmt.Println(\"Ni 1 ni 5\")\r\n}</code></pre></div>\n<p>Pero sin embargo la consola nos muestra:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Uno\r\nCinco</code></pre></div>\n<h2>Switch con interfaces</h2>\n<p>Podemos usar interfaces para por ejemplo saber de que tipo es un valor</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var condicion interface{} = 1 // podemos asignar cualquier valor de los aprendidos en este tutorial\r\n\r\nswitch condicion.(type) { // Conseguiríamos el type de la interfaz\r\ncase int, int8, int16, int32, int64:\r\n\tfmt.Print(\"Es un entero\")  // Se ejecutaría este case\r\ncase float32, float64:\r\n\tfmt.Print(\"Es un decimal\")\r\ncase string:\r\n\tfmt.Print(\"Es una cadena de texto\")\r\n}</code></pre></div>\n<h1>For</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for i := 1; i &lt; 6; i++ {\r\n\t// Imprimiría en consola 1 2 3 4 5 \r\n\tfmt.Print(i)\r\n\tfmt.Print(\" \")\r\n}</code></pre></div>\n<h1>ForEach</h1>\n<p>podemos manejar individualmente los valores de un slice o array por ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []int{1, 2, 3}\r\nfor index, valor := range slice {\r\n\tfmt.Print(index, valor)\r\n}</code></pre></div>\n<p>Si queremos omitir el index usaremos el <code class=\"language-text\">_</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slice := []int{1, 2, 3}\r\nfor _, value := range slice {\r\n\tfmt.Print(value)\r\n}</code></pre></div>\n<p>para mapas podremos obtener tanto el value como la key del mapa aunque siempre podremos omitir alguno de los mismos con <code class=\"language-text\">_</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">profesiones := map[int]string{\r\n\t675: \"Soldado\",\r\n\t432: \"Paladín\",\r\n\t321: \"Dragontino\",\r\n\t968: \"Lancero\",\r\n}\r\n\r\nfor index, value := range profesiones {\r\n\tfmt.Println(index, value)\r\n}</code></pre></div>\n<p>tambien podremos usar strings</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cadena := \"HolaMundo\"\r\nfmt.Println(\"Índice | Valor Unicode | Valor en String\")\r\nfor index, value := range cadena {\r\n\tfmt.Println(index, value, string(value))\r\n}</code></pre></div>\n<p>en este caso tendremos la siguiente salida (Lo ordeno en una tabla para que se vea mejor)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Indice</th>\n<th align=\"center\">Valor unicode</th>\n<th align=\"center\">Valor en String</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">72</td>\n<td align=\"center\">H</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">111</td>\n<td align=\"center\">o</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">108</td>\n<td align=\"center\">l</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">97</td>\n<td align=\"center\">a</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">77</td>\n<td align=\"center\">M</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">117</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">110</td>\n<td align=\"center\">n</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">100</td>\n<td align=\"center\">d</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\">111</td>\n<td align=\"center\">o</td>\n</tr>\n</tbody>\n</table>\n<h1>Labels</h1>\n<h2>Breaks</h2>\n<p>Al igual que java se pueden hacer uso de las label para por ejemplo en el caso de que tengamos 2 fors</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tfor i := 1; i &lt; 6; i++ {\r\n\t\tfor j := 0; j &lt; 6; j++ {\r\n\t\t\tbreak // esto rompería la ejecución del for con la variable j\r\n\t\t}\r\n\t}\r\nlabel2:\r\n\tfor i := 1; i &lt; 6; i++ {\r\n\t\tfor j := 0; j &lt; 6; j++ {\r\n\t\t\t// en cambio este rompería la ejecución de todo\r\n\t\t\t// ya que la label \"label2\" está por encima de los 2 for\r\n\t\t\tbreak label2 \r\n\t\t}\r\n\t}</code></pre></div>\n<h1>Defer</h1>\n<p>defer es la técnica por la cual el statement que vaya precedido de él se ejecutará el último inmediatamente antes del return de la función (en el caso de que no haya return será el ultimo statement en ejecutarse) un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fmt.Println(1)\r\ndefer fmt.Println(2) // statement deferido\r\nfmt.Println(3)</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1\r\n3\r\n2</code></pre></div>\n<p>Ahora que pasa si tenemos varios statements deferidos</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defer fmt.Println(1)\r\ndefer fmt.Println(2)\r\ndefer fmt.Println(3)</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">3\r\n2\r\n1</code></pre></div>\n<p>El comportamiento que nos vendría a la cabeza que tendría que tener este código debería de ser 1 2 3 ya que se ejecuta todo al final del método, pero en cambio obtenemos justo lo contrario</p>\n<p>Esto es debido a que los statements deferidos funcionan por FILO (First In Last Out) imagina una pila de libros y ten presente la regla de que solo puedes coger 1 a la vez si apilas 3 libros libro1 libro2 y libro3 en ese orden concreto cuando quieras coger esos libros el primero que recogerás es el libro3</p>\n<p>Ocurre lo mismo con los statements deferidos el ultimo que entra es el primero en salir</p>\n<h2>Usos</h2>\n<p>Los usos de esto podría ser por ejemplo el cierre de recursos , podrías tener al final del método el cierre de los mismos pero podrías olvidarte de todos los recursos que tienes que cerrar haciendo defer asociarías el abrir del recurso con el cerrar del mismo inmediatamente despues (aunque realmente lo ejecutarías al final de la función)</p>\n<h3>Problemas</h3>\n<p>Una cosa a tener en cuenta es que por ejemplo si estás en un for loop y el usar el defer para cerrar un recurso que esté en ese for cuando realmente se va a ejecutar ese statement es al final de la función lo del for loop podrías tener miles de recursos abiertos a la vez así (que luego se cerrarían pero no deberías ya que podría dar lugar a fallos o problemas de rendimiento)</p>\n<h3>Soluciones</h3>\n<p>Una opción sería delegar ese cierre de recurso a una función y hacer ahí el defer</p>\n<h2>Llamadas a funciones y parámetros</h2>\n<p>Según lo que vimos anteriormente podrías pensar que este codigo imprimiría <code class=\"language-text\">final</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">variable := \"comienzo\"\r\ndefer fmt.Print(variable)\r\nvariable = \"final\"</code></pre></div>\n<p>Pero la realidad es que imprimiría <code class=\"language-text\">comienzo</code> esto es debido a que en las llamadas a funciones deferidas lo que se va a ejecutar coge los valores de los argumentos que tuviera en ese momento esa variable de tal manera que en nuestro ejemplo cogería el valor <code class=\"language-text\">comienzo</code></p>\n<h1>Panicking</h1>\n<p>Esto es por ejemplo un erro grave en Go , no hay muchos casos por lo que se pueda dar un error grave del que la aplicación no sepa como seguir por ejemplo el típico caso sería una petición a un servidor remoto en el que no se recibe respuesta alguna , esto no es causa de un panic ya que tendremos un valor de error para interpretar en este caso por ejemplo un 500 o un 404 por decir algunos</p>\n<p>Un ejemplo de panic sería que estás intentand leer una plantilla para generar una página web pues bien si no se puede leer esa plantilla no se puede seguir porque sería un error grave del que no puedes recuperarte</p>\n<p>por otro lado si vas a abrir un fichero de log y no puedes abrirle ese no es un panic ya que la ejecución puede seguir</p>\n<p>En go un error grave es lo que se le llama un panic ya que la aplicación no sabe que hacer despues de eso:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tnumero1, numero2 := 1, 0\r\n\tdivision := numero1 / numero2\r\n\tfmt.Print(division)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">panic: runtime error: integer divide by zero\r\n\r\ngoroutine 1 [running]:\r\nmain.main()\r\n        C:/Users/MaQuiNa1995/workspace/Go_Workspace/HolaMundo/src/maquina1995/hola.mundo/Main.go:11 +0x11\r\nexit status 2</code></pre></div>\n<h2>Provocar panics</h2>\n<p>Podemos probecar errores manualmente gracias a la funcion panic()</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fmt.Println(\"Comienzo\")\r\npanic(\"Algo malo ha pasado\")\r\n// el IDE nos avisará de que este statement no va a ejecutarse\r\nfmt.Println(\"Fin\") </code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Comienzo\r\npanic: Algo malo ha pasado\r\n\r\ngoroutine 1 [running]:\r\nmain.main()\r\n        C:/Users/MaQuiNa1995/workspace/Go_Workspace/HolaMundo/src/maquina1995/hola.mundo/Main.go:14 +0x65\r\nexit status 2</code></pre></div>\n<p>Un tema importante es que el panic será ejecutado justo despues de los statements que hayan sido deferidos asique nuestros posibles cierres de recursos que tengamos deferidos podrán ejecutarse normalmente</p>\n<h1>Recover</h1>\n<p>Es usado para salvar un error grave (panic) , solo es útil en statements que estén deferidos ya que como hablamos anteriormente estos se ejecutan antes del panic por lo tanto podrán arreglar el error</p>\n<p>Cuando se produce un error la función que se estuviera ejecutando en ese momento para su ejecución pero si salvas ese error las funciones padre que hayan llamado a esta podrían seguir la ejecución</p>\n<p>un ejemplo de un manejo de excepción:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\tfmt.Print(\"Empieza el main\")\r\n\tnumero := -1\r\n\tstart(numero)\r\n\tfmt.Printf(\"Acaba el main\")\r\n}\r\n\r\nfunc start(numero int) {\r\n\r\n\t// Requiere que esté deferida para\r\n\t// que pueda manejar la excepción\r\n\t// tambien puede ser una función anónima\r\n\tdefer manejarExcepcion()\r\n\tif numero == 0 {\r\n\t\tpanic(\"Error: el valor de número no puede ser cero\")\r\n\t}\r\n\tfmt.Printf(\"El número es %v\\n\", numero)\r\n}\r\n\r\nfunc manejarExcepcion() {\r\n\tif exception := recover(); exception != nil {\r\n\t\tfmt.Println(\"Manejando la excepción: \", exception)\r\n\t}\r\n}</code></pre></div>\n<h1>Punteros</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numero1 := 1\r\n// aunque se asigne a numero2 apuntan\r\n// a distintas direcciones de memoria\r\nnumero2 := numero1\r\nfmt.Println(numero1, numero2) // 1 1\r\n\r\n// al no apuntar a la misma dirección de memoria\r\n// aunque asignemos el valor 0 numero2 no se ve afectada\r\nnumero1 = 8\r\nfmt.Println(numero1, numero2) // 8 1</code></pre></div>\n<h2>Creación</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var numero1 int = 1\r\n// Hemos creado un puntero para indicar\r\n// que numero2 va a tener un puntero de tipo integer\r\n// a la variable numero 2\r\nvar numero2 *int = &amp;numero1\r\nfmt.Println(numero1, numero2) // 1 0xc0000aa058\r\n\r\n// Ahora al apuntar a la misma referencia de memoria\r\n// Al cambiar uno el otro tambien se ve reflejado\r\nnumero1 = 8\r\nfmt.Println(numero1, numero2) // 8 0xc0000aa058</code></pre></div>\n<p>Ahora el 0xc0000aa058 representaría la dirección de memoria donde estaría almacenado el valor 8 podemos probar esto convirtiendo la variable numero1 a un puntero añadiendo el siguiente statement al código anterior <code class=\"language-text\">fmt.Println(&amp;numero1) // 0xc0000aa058 0xc0000aa058</code></p>\n<h2>Deferenciación</h2>\n<p>Podemos recuperar un valor que esté almacenado en un puntero gracias a <code class=\"language-text\">*</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var numero1 int = 1\r\nvar numero2 *int = &amp;numero1\r\nfmt.Println(numero1, numero2) // 1 0xc0000aa058\r\n\r\nnumero1 = 8\r\n// Al usar el asterisco estamos reemplazando el\r\n// valor de la memoria donde está almacenada por su valor real\r\nfmt.Println(numero1, *numero2) // 8 8</code></pre></div>\n<h1>Funciones</h1>\n<p>Una aplicación siempre debe tener un punto de entrada:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// siempre en el paquete main\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\n// Sin parámetros y llamada main\r\nfunc main() {\r\n\tfmt.Print(\"Empieza el main\")\r\n}</code></pre></div>\n<h2>Convención de nombres</h2>\n<p>Se sigue las reglas normales ya descritas en la guía pascalCase o camelCase con la primera minuscula (solo disponible para ese fichero) y con la primera mayúscula para que pueda ser accedido desde toda la aplicación</p>\n<h2>Parámetros</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\tpintarEnConsola(\"mensaje\")\r\n}\r\n\r\n// func nombre (nombreVariable tipo, ...) \r\nfunc pintarEnConsola(mensaje string) {\r\n\tfmt.Print(mensaje)\r\n}</code></pre></div>\n<p>Si tienes mas de 1 variable del mismo tipo podrías agruparlas</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func pintarEnConsola(mensaje, mensaje2 string, numero int) {\r\n\tfmt.Print(mensaje, mensaje2, numero)\r\n}</code></pre></div>\n<h2>Punteros en parámetros de funciones</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\tsaludo := \"Hola \"\r\n\tnombre := \"MaQuiNa\"\r\n\r\n\tsaludarPorConsola(saludo, nombre)\r\n\r\n\tprintln(\"Hemos saludado a\", nombre)\r\n}\r\n\r\nfunc saludarPorConsola(saludo, nombre string) {\r\n\tfmt.Println(saludo, nombre)\r\n\tnombre = \"nombreCambiado\"\r\n}</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hola  MaQuiNa\r\nHemos saludado a MaQuiNa</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\tsaludo := \"Hola \"\r\n\tnombre := \"MaQuiNa\"\r\n\r\n\tsaludarPorConsola(&amp;saludo, &amp;nombre)\r\n\r\n\tprintln(\"Hemos saludado a\", nombre)\r\n}\r\n\r\nfunc saludarPorConsola(saludo, nombre *string) {\r\n\tfmt.Println(*saludo, *nombre)\r\n\t*nombre = \"nombreCambiado\"\r\n}</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hola  MaQuiNa\r\nHemos saludado a nombreCambiado</code></pre></div>\n<h3>Vararg</h3>\n<p>Podemos usar esta notación para wrapear un conjunto de variables en un slice y trabajar con una serie de posibles valores indeterminado</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\tsaludo := \"Hola\"\r\n\tnombre := \"MaQuiNa\"\r\n\tnombre2 := \"MaQuina2\"\r\n\r\n\tsaludarPorConsola(&amp;saludo, nombre, nombre2)\r\n}\r\n\r\nfunc saludarPorConsola(saludo *string, nombres ...string) {\r\n\tfor _, nombre := range nombres {\r\n\t\tfmt.Println(*saludo, nombre)\r\n\t}\r\n}</code></pre></div>\n<p>Puedes incluso no pasar ningun argumento en el parámetro del var arg de modo que en la funcion de antes sería plausible esto: <code class=\"language-text\">saludarPorConsola(&amp;saludo)</code></p>\n<p>De tal manera que entonces el forEach no se ejecutaría ya que nombres estaría vacío</p>\n<h2>Return</h2>\n<p>Podemos retornar mas de 1 valor en go en las funciones esto es util para por ejemplo evitar el uso de panic y controlar el flujo de errores con objetos secundarios un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\tdivision, error := dividir(5.0, 0.0)\r\n\r\n\t// Si error no es nulo quiere decir que hubo excepciones\r\n\tif error != nil {\r\n\t\t// imprimimos por consola el error\r\n\t\tfmt.Print(\"Hubo un error mas info: \", error)\r\n\t\t// paramos la ejecución del método\r\n\t\treturn\r\n\t}\r\n\t// Imprimimos el valor de la división\r\n\tfmt.Print(\"El valor de la división es:\", division)\r\n}\r\n\r\n// En una función podemos retornar mas de un valor\r\n// normalmente el 1º es el resultado de la función\r\n// y los segundos y sucesivos son errores por ejemplo\r\nfunc dividir(dividendo, divisor float64) (float64, error) {\r\n\r\n        // En go usamos las ward clausules en la medida\r\n        // de lo posible para evitar piramides infernales de ifs\r\n\tif divisor == 0.0 {\r\n\t\t// En vez de controlar el flujo con panic\r\n\t\t// usamos la String creada a partir de fmt.Errorf\r\n\t\treturn 0.0, fmt.Errorf(\"No se puede dividir entre 0\")\r\n\t}\r\n\r\n\t// retornamos el valor de la división y nil\r\n\t// que indica que no hubo error\r\n\treturn dividendo / divisor, nil\r\n}</code></pre></div>\n<h2>Funciones anónimas</h2>\n<p>En go podemos crear funciones dentro de funciones</p>\n<h3>Simple</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n        // Declaramos la funcion\r\n\tfunc() {\r\n\t\tfmt.Print(\"Hola\")\r\n        // y con los `()` hacemos la llamada a\r\n        // la misma inmediatamente\r\n\t}()\r\n}</code></pre></div>\n<h3>Problema en entornos asincronos</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\r\n\t// podemos usar variables de fuera de la\r\n\t// función ya que está en el mismo scope\r\n\t// Aqui el problema es que en cuanto vayamos\r\n\t// a la programación asincrona vamos a tener problemas\r\n\tfor i := 0; i &lt; 5; i++ {\r\n\t\tfunc() {\r\n\t\t\tfmt.Print(i)\r\n\t\t}()\r\n\t}\r\n\t// Esto en cambio tiene garantizado el correcto\r\n\t//funcionamiento en entornos asincronos\r\n\t// ya que se le pasa el valor vada ciclo\r\n\tfor i := 0; i &lt; 5; i++ {\r\n\t\tfunc(i int) {\r\n\t\t\tfmt.Print(i)\r\n\t\t}(i)\r\n\t}\r\n}</code></pre></div>\n<h2>Funciones como tipos</h2>\n<p>En go podemos tener funciones como variables un ejemplo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func main() {\r\n\r\n\t// Aqui declararíamos la función\r\n\tfuncion := func() {\r\n\t\tfmt.Print(\"saludos desde dentro de una función\")\r\n\t}\r\n\r\n\t// Aqui tenemos otra forma de declarar una función\r\n\tvar funcion2 func() = func() {\r\n\t\tfmt.Print(\"saludos desde otra función nueva\")\r\n\t}\r\n\r\n\t// aqui las ejecutaríamos\r\n\tfuncion()\r\n\tfuncion2()\r\n\r\n}</code></pre></div>\n<h2>Métodos</h2>\n<p>Son básicamente los mismo que una función solo que le damos un contexto donde ejecutarse para asi por ejemplo de 1 struct podemos definir “métodos” como si por ejemplo en java en una clase metiéramos un método un ejemplo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type hechicero struct {\r\n\tmana   int\r\n\tnombre string\r\n}\r\n\r\nfunc main() {\r\n\r\n\tmago := hechicero{\r\n\t\t100,\r\n\t\t\"MaQuiNa\",\r\n\t}\r\n\r\n\tfmt.Println(\"Maná actual del mago: \", mago.mana)\r\n\t// Aunque el struct no tenga este metodo hemos anclado esa función a ese tipo\r\n\tmago.lanzarHechizo()\r\n\tfmt.Println(\"Maná actual del mago: \", mago.mana)\r\n}\r\n\r\n// en este caso estamos \"añadiendo\" una función para poder ser invocada desde hechicero\r\n// de tal manera aunque los struct no puedan tener una función dentro como si de una clase\r\n// y un método en java serían podemos vincular una función a cierto struct\r\n\r\n// notese que si queremos que los cambios que hagamos a este struct se hagan\r\n// efectivos para en este caso la función main desde donde hemos pasado el struct\r\n// necesitamos marcar el tipo del parámetro con un *\r\nfunc (mago *hechicero) lanzarHechizo() {\r\n\tmago.mana = mago.mana - 10\r\n\tfmt.Println(mago.nombre, \" Lanza Bola de fuego maná restante: \", mago.mana)\r\n}</code></pre></div>\n<p>Resultado:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Maná actual del mago:  100\r\nMaQuiNa  Lanza Bola de fuego maná restante:  90\r\nManá actual del mago:  90</code></pre></div>\n<h1>Interfaces</h1>\n<p>Las interfaces no describen datos como los structs , sino comportamientos un ejemplo del uso de las mismas:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*\r\n Se define un comportamiento es decir en este caso se va a\r\n escribir bytes en algun lugar ya sea un fichero una conexión TCP\r\n solo nos interesa lo que entra y lo que sale de la función\r\n esto es lo que denominamos \"comportamiento\"\r\n\r\n Lo que devuelva será (nº de bytes escritos y el posible\r\n\terror que pueda producirse) respectivamente\r\n*/\r\ntype Escritor interface {\r\n\tWrite([]byte) (int, error)\r\n}\r\n\r\n/*\r\n Ahora solo necesitamos un struct que implemente esa interfaz\r\n si vienes de otros lenguajes tipo java esperarías algo tipo\r\n implements para implementar la interfaz pero en go , eso se hace\r\n creando un método con la misma firma que el método de la interfaz\r\n que acepte este struct\r\n*/\r\ntype EscritorConsola struct{}\r\n\r\n/*\r\n Aqui definimos la implementación de la interfaz\r\n*/\r\nfunc (escritorConsola EscritorConsola) Write(bytesEscribir []byte) (int, error) {\r\n\tbytesEscritos, error := fmt.Print(string(bytesEscribir))\r\n\treturn bytesEscritos, error\r\n}\r\n\r\nfunc main() {\r\n\r\n\t// De tal manera que puedo sustituir EscritorConsola{} por por ejemplo\r\n\t// EscritorArchivo{} ya que ese tambien implementaría la interfaz Escritor\r\n\t// porque cumple el contrato(método) de la misma\r\n\tvar escritor Escritor = EscritorConsola{}\r\n\tescritor.Write([]byte(\"Hola mundo\"))\r\n}</code></pre></div>\n<h2>Convención de nombres</h2>\n<ul>\n<li>El nombre de la interfaz debe ser descriptivo de lo que hace</li>\n<li>El nombre de la interfaz debe describir una accion (escribir)</li>\n<li>Si tienes una interfaz con 1 solo método el nombre de la interfaz tendría que ser el nombre del método tambien</li>\n<li>Si tienes mas de un método en la interfaz el nombre debe indicar en conjunto es decir si tienes sumar dividir restar y multiplicar la interfaz se debería de llamar Calcular</li>\n</ul>\n<h2>Interfaces de interfaces</h2>\n<p>Las interfaces de interfaces se usan principalmente para recolectar una serie de utilidades que son a su vez interfaces como podría ser la conexión a una base de datos tendrías por ejemplo un método para abrir la conexión a la misma y otro para cerrarlo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>","frontmatter":{"title":"Golang Desde Cero","date":"December 05, 2021","description":"Guía desde 0 de golang"}},"previous":{"fields":{"slug":"/Golang_Blockchain/"},"frontmatter":{"title":"Golang Blockchain Básico"}},"next":{"fields":{"slug":"/Indice_Github/"},"frontmatter":{"title":"Indice Github"}}},"pageContext":{"id":"b3b735c5-9831-5dc1-aa4b-aa028fa56f48","previousPostId":"aebe1791-9952-5c1d-834f-8a4ef31aa144","nextPostId":"102659b3-020d-5b9b-a93d-8a338f295bcb"}},
    "staticQueryHashes": ["2841359383","3274528899"]}