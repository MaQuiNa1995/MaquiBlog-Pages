{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Golang_Blockchain/",
    "result": {"data":{"site":{"siteMetadata":{"title":"El Rincon Del MaQuinarias"}},"markdownRemark":{"id":"aebe1791-9952-5c1d-834f-8a4ef31aa144","excerpt":"Tabla de contenidos Que es Blockchain Que es el Block Hash Función bytes.Join Creación de un bloque Añadiendo un bloque a la blockchain El bloque “Genesis…","html":"<h1>Tabla de contenidos</h1>\n<ul>\n<li><a href=\"#que-es-blockchain\">Que es Blockchain</a></li>\n<li><a href=\"#que-es-el-block\">Que es el Block</a>\n<ul>\n<li><a href=\"#hash\">Hash</a>\n<ul>\n<li><a href=\"#funci-n-bytesjoin\">Función bytes.Join</a></li>\n</ul>\n</li>\n<li><a href=\"#creaci-n-de-un-bloque\">Creación de un bloque</a></li>\n<li><a href=\"#a-adiendo-un-bloque-a-la-blockchain\">Añadiendo un bloque a la blockchain</a>\n<ul>\n<li><a href=\"#el-bloque--genesis-\">El bloque “Genesis”</a></li>\n</ul>\n</li>\n<li><a href=\"#creaci-n-de-una-blockchain\">Creación de una blockchain</a></li>\n</ul>\n</li>\n<li><a href=\"#ejecuci-n-del-c-digo-hasta-ahora\">Ejecución del código hasta ahora</a></li>\n<li><a href=\"#qu--es-prueba-de-trabajo---proof-of-work--pow-\">Qué es Prueba de trabajo / Proof of Work (PoW)</a></li>\n<li><a href=\"#proof-of-work\">Proof Of Work</a>\n<ul>\n<li><a href=\"#algoritmo-de-proof-of-work\">Algoritmo de Proof Of Work</a></li>\n<li><a href=\"#dificultad\">Dificultad</a></li>\n<li><a href=\"#creando-el-struct\">Creando el Struct</a></li>\n<li><a href=\"#creando-proof-of-work\">Creando Proof of work</a></li>\n<li><a href=\"#iniciar-prueba-de-trabajo\">Iniciar Prueba de trabajo</a></li>\n<li><a href=\"#ejecuci-n-de-la-prueba-de-trabajo-para-firmar-el-bloque\">Ejecución de la prueba de trabajo para firmar el bloque</a></li>\n<li><a href=\"#modificando-el-c-digo-previo\">Modificando el código previo</a></li>\n<li><a href=\"#validar-prueba-de-trabajo\">Validar Prueba de trabajo</a></li>\n<li><a href=\"#juntando-todo-en-el-main\">Juntando todo en el main</a></li>\n</ul>\n</li>\n</ul>\n<h1>Que es Blockchain</h1>\n<p>Es una base de datos publica que está distribuida en múltiples nodos</p>\n<p>Todos los datos que entren deben de ser confiable por todos los nodos</p>\n<p>Podrías por ejemplo tener un 49% de los nodos que produjesen datos erróneos o malintencionados y la red podría recuperarse de ese desajuste</p>\n<p>Un Blockchain implica multiples bloques que contienen la información que queremos en nuestra base de datos</p>\n<p>Struct de un blockchain</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type blockChain struct {\r\n\tblocks []*block\r\n}</code></pre></div>\n<p>En este struct básicamente tenemos un slice de punteros de bloques</p>\n<h1>Que es el Block</h1>\n<p>Básicamente son los objetos que conforman un blockchain este tiene que tener 3 básicos como mínimo</p>\n<p>Atributos</p>\n<ul>\n<li>Hash del propio bloque</li>\n<li>Hash del último bloque creado (Es el que nos permite enlazar bloques)</li>\n<li>El dato que guardamos pueden ser imagenes textos numeros etc</li>\n<li></li>\n</ul>\n<p>Struct de un bloque básico</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type block struct {\r\n\tHash     []byte\r\n\tData     []byte\r\n\tPrevHash []byte\r\n}</code></pre></div>\n<h2>Hash</h2>\n<p>Para el calculo del hash como standard se usa el algoritmo de encriptado SHA-256 debido a su equilibrio entre coste computacional y solidez si quieres aprender mas sobre este algoritmo de encriptación: <a href=\"https://academy.bit2me.com/sha256-algoritmo-bitcoin/\">Pincha Aqui</a></p>\n<p>Para calcular el Hash usaremos este método:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func (b *block) CalculateHash() {\r\n// Explicado mas abajo\r\n\tinfo := bytes.Join([][]byte{b.Data, b.PrevHash}, []byte{})\r\n  // Lo encriptamos \r\n\thash := sha256.Sum256(info)\r\n  // Creamos una copia y se la asignamos al hash del struct\r\n\tb.Hash = hash[:]\r\n}</code></pre></div>\n<h3>Función bytes.Join</h3>\n<p>Lo que hace es juntar los slice de datos que se le pasan como primer parámetro <code class=\"language-text\">[][]byte{b.Data, b.PrevHash}</code> (Pueden ser cualquier cantidad) teniendo como separador el 2º parámetro <code class=\"language-text\">[]byte{}</code> (En este caso vacío)</p>\n<p>un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1º Parámetro\r\nAAAA\r\nBBBB\r\n2º Parámetro\r\nCC\r\nResultado:\r\nAAAACCBBBB</code></pre></div>\n<p><a href=\"https://www.includehelp.com/golang/bytes-join-function-with-examples.aspx\">Documentación función bytes.Join</a></p>\n<h2>Creación de un bloque</h2>\n<p>Para crear un bloque deberías de llamar a esta función para asegurarte de que se calcula el hash por lo tanto sería conveniente hacer “privado” el struct del bloque para que nadie pueda instanciar un bloque de otra forma que no sea a traves de esta función</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func CreateBlock(data string, prevHash []byte) *block {\r\n// Creamos normal un struct\r\n\tblock := &amp;block{\r\n\t\tHash:     []byte{},\r\n    // Aqui adicionalmente pasamos de string a bytes\r\n\t\tData:     []byte(data),\r\n\t\tPrevHash: prevHash,\r\n\t}\r\n  // Llamamos a la función que creamos previamente\r\n\tblock.CalculateHash()\r\n  // Lo retornamos\r\n\treturn block\r\n}</code></pre></div>\n<h2>Añadiendo un bloque a la blockchain</h2>\n<p>para añadir un bloque a la blockchain debemos usar la anterior funcion</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Recibimos una blockchain\r\nfunc (chain *blockChain) AddBlock(data string) {\r\n// Cogemos el ultimos bloque\r\n\tprevBlock := chain.Blocks[len(chain.Blocks)-1]\r\n  // A traves de la función de antes creamos el nuevo bloque\r\n\tnewBlock := CreateBlock(data, prevBlock.Hash)\r\n  // Se lo añadimos a la blockchain\r\n\tchain.Blocks = append(chain.Blocks, newBlock)\r\n}</code></pre></div>\n<h3>El bloque “Genesis”</h3>\n<p>Como hemos visto siempre referenciamos al hash del anterior bloque pero que pasa con el primer bloque este es imposible que pueda tener ningun hash previo ya que este es el primero, a este bloque se le llama “Genesis Block” que representa el primer bloque de la blockchain</p>\n<p>Lo crearemos a traves de este método:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func Genesis() *block {\r\n\treturn CreateBlock(\"Genesis\", []byte{})\r\n}</code></pre></div>\n<h2>Creación de una blockchain</h2>\n<p>Para crear la blockchain debemos usar la función anterior de tal manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func InitBlockChain() *blockChain {\r\n\treturn &amp;blockChain{[]*block{Genesis()}}\r\n}</code></pre></div>\n<h1>Ejecución del código hasta ahora</h1>\n<p>Si quieres ver el estado del repositorio hasta ahora ve a <a href=\"https://github.com/MaQuiNa1995/Go-BlockChain/tree/f8e0bf7d63d0334eac3b3153a8dbbc5e5cb057b9\">este commit</a></p>\n<p>Nuestro main sacará por consola esto:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Bloque:\r\n        Previous Hash:\r\n        Data in Block: Genesis\r\n        Hash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5\r\n\r\nBloque:\r\n        Previous Hash: 81ddc8d248b2dccdd3fdd5e84f0cad62b08f2d10b57f9a831c13451e5c5c80a5\r\n        Data in Block: 1º Block Despues del Genesis\r\n        Hash: 11f27e8a6ee5b1b8d1eada2d6ce758bd7028d86b47dcac4ac27b202eaeedead2\r\n\r\nBloque:\r\n        Previous Hash: 11f27e8a6ee5b1b8d1eada2d6ce758bd7028d86b47dcac4ac27b202eaeedead2\r\n        Data in Block: 2º Block Despues del Genesis\r\n        Hash: d81bbc87021060a1925f297a98fe3b6236481fe42e82c856bb42ea119b3f72bf\r\n\r\nBloque:\r\n        Previous Hash: d81bbc87021060a1925f297a98fe3b6236481fe42e82c856bb42ea119b3f72bf\r\n        Data in Block: 3º Block Despues del Genesis\r\n        Hash: 3f6628fe789a6518e1dfe77075e9f8f88028def45d281580b9f26d0590ee8317</code></pre></div>\n<p>No importa la veces que lo ejecutemos siempre será lo mismo, por lo tanto al ejecutar varias veces este main obtendras varias copias de la blockchain la manera de saber si está corrupto es comparando los hashes de las diferentes copias</p>\n<h1>Qué es Prueba de trabajo / Proof of Work (PoW)</h1>\n<p>Hay diferentes Algoritmos de consenso (Consensus algorithms / Proof Algorithms)</p>\n<ul>\n<li>Proof Of Work</li>\n<li>Proof Of Steak</li>\n<li>y mas…</li>\n</ul>\n<h1>Proof Of Work</h1>\n<p>Básicamente lo que quiere decir este es que forzamos a la red a realizar trabajo para añadir un bloque a la blockchain</p>\n<p>Este “trabajo” es computacional, cuando hablamos de mineros minando Bitcoin nos referimos a esta “Prueba de trabajo” para añadir bloques a la blockchain la razón por la que estos consiguen bitcoins es esencialmente porque potencian a la red a escribir mas rápido ese bloque</p>\n<p>Adicionalmente hacen que el dato de los bloques sea mas seguro, el Proof of work viene de la mano de la validación de esa prueba que es cuando un usuario hace el trabajo necesario para añadir ese bloque se requiere que demuestre ese trabajo realizado de ahi el nombre de “Prueba de trabajo” (Proof of Work)</p>\n<p>Un concepto importante es que el trabajo realizado debe ser dificil pero la demostración del mismo debe ser relativamente fácil</p>\n<h2>Algoritmo de Proof Of Work</h2>\n<p>Los pasos a seguir van a ser:</p>\n<ul>\n<li>Coger el dato del bloque</li>\n<li>Crear un contador que empiece en el 0 (Llamado nonce) que será incrementado en +1 teóricamente infinitas veces</li>\n<li>Crear el hash del dato + el nonce</li>\n<li>Verificar el hash para ver si cumple determinados requerimientos de aqui viene la llamada “dificultad”\n<ul>\n<li>Requerimientos:\n<ul>\n<li>Los primeros bytes deben contener 0</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Digamos que quieres escribir un bloque, si el hash de ese nuevo bloque no cumple los requerimientos tendrás que volver a generar el hash ese reintento es a lo que se le llama dificultad teniendo que recrear otro hash para ver si cumple con los requerimientos</p>\n<p>En la proof of Work original de bitcoin la especificación se llama “Hash cash”</p>\n<p>En la dificultad original se requería que 20 bytes consecutivos del hash fueran 0, con el paso del tiempo esa dificultad se ha incrementado por lo tanto se requiere de mas trabajo para poder escribir un bloque</p>\n<p>Podemos aumentar la dificultad por ejemplo haciendo que el requerimiento de 20 ceros pase a 50</p>\n<h2>Dificultad</h2>\n<p>Para empezar definiremos una constante para definir la dificultad: <code class=\"language-text\">const difficulty = 18</code></p>\n<p>Tendremos una dificultad estática en nuestra prueba de concepto pero si quieres crear un algoritmo de blockchain de verdad tendrás que crear algún tipo de función que incremente la dificultad de poco en poco dentro de un periodo de tiempo largo, básicamente quieres que esto suceda para aumentar el número de mineros en la red y la potencia creciente de los ordenadores que pudieran venir en el futuro. Queremos que el tiempo de minado de un bloque sea uniforme</p>\n<h2>Creando el Struct</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type ProofOfWork struct {\r\n        // Representa un puntero a un bloque\r\n\tBlock  *block\r\n\t// Representa un puntero que es el requerimiento que hemos definido arriba \r\n\t// para entender esto necesitas saber como los bytes se comportan en el ordenador\r\n\tTarget *big.Int\r\n}</code></pre></div>\n<p><a href=\"https://golang.org/pkg/math/big/\">Big Int en Go</a>\r\n<a href=\"https://golang.org/pkg/bytes/\">Bytes en Go</a></p>\n<h2>Creando Proof of work</h2>\n<p>Con está función desde un puntero a un bloque obtendríamos un puntero a una prueba de trabajo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func NewProof(b *block) *ProofOfWork {\r\n        // Crearemos nuestro target \r\n\ttarget := big.NewInt(1)\r\n\t// Despues tendremos que coger el 256 que es el número de bytes de los hashes\r\n\t// y extraer la dificultad de ellos , para despues hacer un left shift (Lsh) de los bytes de ese número\r\n\ttarget.Lsh(target, uint(256-difficulty))\r\n\t// Ahora cogemos ese valor al que le hemos hecho el left shifted\r\n\t// y lo metemos a nuestro struct\r\n\tpow := &amp;ProofOfWork{\r\n\t\tBlock: b,\r\n\t\tTarget: target,\r\n\t}\r\n\t// Despues lo retornamos\r\n\treturn pow\r\n}</code></pre></div>\n<h2>Iniciar Prueba de trabajo</h2>\n<p>Este método será el que inicie los datos de la prueba de trabajo tendremos que combinar:</p>\n<ul>\n<li>Hash del bloque previo</li>\n<li>Hash del dato</li>\n<li>Hash del contador</li>\n<li>Hash de la dificultad</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func (pow *ProofOfWork) InitData(nonce int) []byte {\r\n\r\n\t// usaremos el bytes.Join\r\n\tdata := bytes.Join(\r\n\t\t[][]byte{\r\n\t\t\t// Meteremos el prevHash y el dato\r\n\t\t\tpow.Block.PrevHash,\r\n\t\t\tpow.Block.Data,\r\n\t\t\t// Adicionalmente meteremos el nonce y la dificultad\r\n\t\t\t// Acordarse de cuando hablamos del algoritmo de proof of work \r\n\t\t\t// Crear el hash del dato + el nonce\r\n\t\t\t// Para simplificar las cosas crearemos una nueva\r\n\t\t\t// función que explicaremos a continuación y castearemos\r\n\t\t\t// los int a int 64 para pasarseles a ToHex()\r\n\t\t\tToHex(int64(nonce)),\r\n\t\t\tToHex(int64(difficulty)),\r\n\t\t},\r\n\t\t[]byte{},\r\n\t)\r\n\r\n\treturn data\r\n}\r\n\r\n// De un int64 obtendremos un slice de bytes simplemente\r\nfunc ToHex(num int64) []byte {\r\n\tbuff := new(bytes.Buffer)\r\n\terr := binary.Write(buff, binary.BigEndian, num)\r\n\tif err != nil {\r\n\t\tlog.Panic(err)\r\n\t}\r\n\treturn buff.Bytes()\r\n}</code></pre></div>\n<h2>Ejecución de la prueba de trabajo para firmar el bloque</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func (pow *ProofOfWork) Run() (int, []byte) {\r\n\tvar intHash big.Int\r\n\tvar hash [32]byte\r\n\r\n\t// Iniciamos el contador\r\n\tnonce := 0\r\n\r\n\t// Haremos una especie de do while (Si venís de otro lenguaje)\r\n\t// En este loop prepararemos nuestro dato y\r\n\t// luego lo hashearemos a sha-256\r\n\t// Seguidamente convertiremos ese Hash a un biginteger\r\n\t// Por ultimo compararemos ese biginteger generado con el del target\r\n\t// Que estará dentro de nuestro struct de proof of work\r\n\tfor nonce &lt; math.MaxInt64 {\r\n\t\t// Llamaremos a nuestro InitData para preparar el dato\r\n\t\tdata := pow.InitData(nonce)\r\n\t\t// Los hashearemos\r\n\t\thash = sha256.Sum256(data)\r\n\r\n\t\t// Con fines de demostración hacemos un log en pantalla\r\n\t\tfmt.Printf(\"\\r%x\", hash)\r\n\r\n\t\t// haremos una copia del slice\r\n\t\tintHash.SetBytes(hash[:])\r\n\r\n\t\t// Ahora compararemos el hash generado con el del target\r\n\t\tif intHash.Cmp(pow.Target) == -1 {\r\n\t\t\t// Si el hash generado es menor nos salimos del bucle\r\n\t\t\t// Ya que esto quiere decir que hemos podido firmar el bloque\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// De otra forma seguimos incrementando el contador para repetir el proceso\r\n\t\tnonce++\r\n\t}\r\n\t// hacemos un salto de línea para separar trazas\r\n\tfmt.Println()\r\n\r\n\t// retornamos el contador y una copia del slice\r\n\treturn nonce, hash[:]\r\n}</code></pre></div>\n<h2>Modificando el código previo</h2>\n<p>Ahora necesitaremos cambiar el código del bloque para añadir el contador y poder implementar la validación de los requerimientos</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type block struct {\r\n\tHash     []byte\r\n\tData     []byte\r\n\tPrevHash []byte\r\n\tNonce    int // Campo nuevo\r\n}\r\n\r\nfunc CreateBlock(data string, prevHash []byte) *block {\r\n\r\n\tblock := &amp;block{\r\n\t\tHash:     []byte{},\r\n\t\tData:     []byte(data),\r\n\t\tPrevHash: prevHash,\r\n\t\tNonce:    0, // inicializamos el nonce a 0\r\n\t}\r\n\r\n\tblock.CalculateHash()\r\n\treturn block\r\n}</code></pre></div>\n<p>Eliminaremos tambien la función CalculateHash()</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func (b *block) CalculateHash() {\r\n\tinfo := bytes.Join([][]byte{b.Data, b.PrevHash}, []byte{})\r\n\thash := sha256.Sum256(info)\r\n\tb.Hash = hash[:]\r\n}</code></pre></div>\n<p>y cambiamos completamente la función que creaba bloques</p>\n<p>Para rellenar con el nonce nuestro struct:</p>\n<ul>\n<li>Crear la prueba de trabajo</li>\n<li>Ejecutar la prueba de trabajo</li>\n<li>Informar el nonce y el hash en el bloque</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func CreateBlock(data string, prevHash []byte) *block {\r\n\r\n   block := &amp;block{\r\n   \tHash:     []byte{},\r\n   \tData:     []byte(data),\r\n   \tPrevHash: prevHash,\r\n   \tNonce:    0, // inicializamos el nonce a 0\r\n   }\r\n\r\n   // creamos la prueba de trabajo\r\n   pow := NewProof(block)\r\n\r\n   // Y la iniciamos\r\n   nonce, hash := pow.Run()\r\n\r\n   // Cuando hayamos completado la prueba de trabajo\r\n   // podremos rellenar el nonce y el hash obtenido\r\n   block.Hash = hash[:]\r\n   block.Nonce = nonce\r\n\r\n   return block\r\n}</code></pre></div>\n<h2>Validar Prueba de trabajo</h2>\n<p>Básicamente lo que se quiere hacer aqui es ejecutar el ciclo que ha hecho la prueba de trabajo una vez mas para ver si ese hash que se ha obtenido de la 1º ejecución es válido esto podría evitar por ejemplo que de casualidad a fuerza bruta demos con un hash correcto</p>\n<p>Es decir no valdría con solo proveer del hash correcto sino tambien proveer de los pasos que has hecho para llegar a ese hash gracias al nonce (contador) por fuerza bruta sería inviable ya que por cada hash tendrías que ejecutar N veces el nonce es decir:</p>\n<p>Por fuerza bruta generamos (pongamos 3):</p>\n<ul>\n<li>111222333\n<ul>\n<li>Generamos el par con nonce 1</li>\n<li>Generamos el par con nonce 2</li>\n<li>etc</li>\n</ul>\n</li>\n<li>222333444\n<ul>\n<li>Generamos el par con nonce 1</li>\n<li>Generamos el par con nonce 2</li>\n<li>etc</li>\n</ul>\n</li>\n<li>333444555\n<ul>\n<li>Generamos el par con nonce 1</li>\n<li>Generamos el par con nonce 2</li>\n<li>etc</li>\n</ul>\n</li>\n</ul>\n<p>Por lo tanto si ya es dificil dar con el hash correcto imagínate tener que probar N veces con el nonce se hace prácticamente inviable ya que da millones y millones de combinaciones por no decir trillones…</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">func (pow *ProofOfWork) Validate() bool {\r\n\tvar intHash big.Int\r\n\r\n        // Aqui está el truco de la validación explicada mas abajo\r\n\tdata := pow.InitData(pow.Block.Nonce)\r\n\r\n\thash := sha256.Sum256(data)\r\n\tintHash.SetBytes(hash[:])\r\n\r\n\treturn intHash.Cmp(pow.Target) == -1\r\n}</code></pre></div>\n<p>Al crear el bloque el nonce que se le pasa es 0 pero aqui directamente es uno que se ha calculado por lo tanto de primeras crearemos el hash correcto de aqui viene lo que decíamos antes de que probar la validez de la prueba de trabajo es relativamente fácil</p>\n<p>Como dijimos antes:</p>\n<ul>\n<li>Realizar la prueba de trabajo es dificil</li>\n<li>Pero probarla es relativamente fácil</li>\n</ul>\n<p>Si quieres cambiar el hash de un bloque vas a tener que recalcular el hash propio (que eso ya es bastante costoso) y los hashes de los bloques siguientes y aparte hacer creer que ese bloque que has metido es un bloque confiable</p>\n<p>Podemos validar un bloque relativamente rápido pero el trabajo para crear el bloque y firmarle es muy dificil por lo tanto podemos afirmar que es muy dificil manipular un bloque por una o una gran cantidad de entidades</p>\n<h2>Juntando todo en el main</h2>\n<p>Por últimos tenemos que añadir esta prueba de trabajo a nuestro main</p>\n<p>Antes del final del loop añadiremos:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pow := model.NewProof(block)\r\nfmt.Printf(\"Prueba de Trabajo: %s\\n\\n\", strconv.FormatBool(pow.Validate()))</code></pre></div>\n<p><a href=\"https://github.com/MaQuiNa1995/Go-BlockChain/tree/2a67da8b90523cb669a2cb8b0f6a65931bc6cade\">Código en el repo hasta aqui</a></p>","frontmatter":{"title":"Golang Blockchain Básico","date":"December 05, 2021","description":"Guía básica de conceptos de blockchain con golang"}},"previous":null,"next":{"fields":{"slug":"/Golang_Desde_Cero/"},"frontmatter":{"title":"Golang Desde Cero"}}},"pageContext":{"id":"aebe1791-9952-5c1d-834f-8a4ef31aa144","previousPostId":null,"nextPostId":"b3b735c5-9831-5dc1-aa4b-aa028fa56f48"}},
    "staticQueryHashes": ["2841359383","3274528899"]}